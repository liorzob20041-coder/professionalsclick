{% extends "base.html" %}

{% block title %}בעלי מקצוע בקליק — מחשבון{% endblock %}

{% block extra_head %}
  {{ super() }}
  <link rel="stylesheet" href="{{ static_rel('css/estimate.css') }}">
{% endblock %}

{% block content %}
  {% set t = i18n_est or {} %}
  {% set contact_url = url_for('contact', lang=g.current_lang or 'he') %}
  {% set categories = [
    {"id": "electricity", "emoji": "\u26A1\uFE0E", "label": t.get('categories.electricity', 'חשמל')},
    {"id": "plumbing", "emoji": "\U0001F6B0\uFE0E", "label": t.get('categories.plumbing', 'אינסטלציה')},
    {"id": "painting", "emoji": "\U0001F58C\uFE0E", "label": t.get('categories.painting', 'צביעה')},
    {"id": "renovation", "emoji": "\U0001F6E0\uFE0E", "label": t.get('categories.renovation', 'שיפוצים')}
  ] %}
  {% set progress_steps = [
    {"id": "category", "label": t.get('ui.progress_stage_category', 'בוחרים תחום')},
    {"id": "job", "label": t.get('ui.progress_stage_job', 'בוחרים את סוג העבודה')},
    {"id": "subtype", "label": t.get('ui.progress_stage_subtype', 'מדייקים את סוג העבודה')},
    {"id": "quote", "label": t.get('ui.progress_stage_quote', 'עונים על כמה שאלות ממוקדות')}
  ] %}
  <section class="est-page" aria-label="מחשבון הצעת מחיר">

    {% set header_prefix = t.get('ui.header_title_prefix', 'קבלו הערכת מחיר') %}
    {% set header_highlight = t.get('ui.header_title_highlight', 'מדויקת') %}
    {% set header_suffix = t.get('ui.header_title_suffix', 'תוך דקות') %}
    <header class="est-hero" data-est-header>
      <h1 class="est-hero__title">
        {{ header_prefix }} <span class="est-hero__highlight">{{ header_highlight }}</span> {{ header_suffix }}
      </h1>
      <p class="est-hero__lead">{{ t.get('ui.header_tagline', 'ענו על כמה שאלות קצרות וקבלו טווח מחיר משוער מבוסס על נתונים ריאליים של אלפי פרויקטים') }}</p>
    </header>


    <div class="est-shell" data-est-contact="{{ contact_url }}">
      <div class="est-shell__card">
        <div class="est-shell__meta">
          <div class="est-progresswrap">
            <div class="est-progress__meta">
              <span class="est-progress__primary" data-est-progress-primary>{{ t.get('ui.progress_stage_category', 'בוחרים תחום') }}</span>
              <span class="est-progress__secondary" data-est-progress-secondary>{{ t.get('ui.progress_step_counter', 'שלב 1 מתוך 4') }}</span>
            </div>
            <div class="est-progressboard">
              <div class="est-progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" data-est-progress>
                <div class="est-progress__bar"></div>
              </div>
              <ol class="est-stepper" role="list" style="--step-count: {{ progress_steps|length }}">
                {% for step in progress_steps %}
                  <li class="est-stepper__item{% if loop.first %} is-active{% endif %}"
                      data-est-progress-step="{{ step.id }}"{% if loop.first %} aria-current="step"{% endif %}>
                    <span class="est-stepper__bullet" aria-hidden="true" data-step-index="{{ loop.index }}"></span>
                    <span class="est-stepper__label" data-est-progress-label data-default-label="{{ step.label }}">{{ step.label }}</span>
                  </li>
                {% endfor %}
              </ol>
            </div>
          </div>
          <div class="est-journey" data-est-journey>
            <span class="est-journey__empty">{{ t.get('ui.journey_empty', 'עוד לא בחרתם כלום — נתחיל בבחירת תחום.') }}</span>
          </div>
        </div>
        <section class="est-convo" aria-label="שיחה עם מחשבון ההצעה">
          <div class="est-convo__body" data-est-body aria-live="polite"></div>
        </section>
      </div>
    </div>
    <section class="est-content" aria-labelledby="est-info-heading">
      <div class="est-content__block">
        <h2 class="est-content__title" id="est-info-heading">איך המחשבון עובד?</h2>
        <p class="est-content__text">
          המחשבון החכם שלנו מוביל אתכם שלב אחר שלב, שואל שאלות קצרות ומחשב טווחי מחיר אמיתיים בהתבסס על פרויקטים דומים.
          בכל שלב אפשר לעדכן תשובות, להוסיף עבודות נוספות ולשמור על שליטה מלאה בתהליך.
        </p>
        <ul class="est-content__list">
          <li>הנחיה מותאמת אישית בשפה פשוטה וברורה.</li>
          <li>תמיכה מלאה בכתיבה מימין לשמאל ובמובייל.</li>
          <li>תוצאה מיידית שניתן לשתף או לשמור להמשך.</li>
        </ul>
      </div>
      <div class="est-content__block" aria-labelledby="est-faq-heading">
        <h2 class="est-content__title" id="est-faq-heading">שאלות נפוצות</h2>
        <div class="est-faq">
          <article class="est-faq__item">
            <h3 class="est-faq__question">כמה מדויקת התוצאה?</h3>
            <p class="est-faq__answer">הטווחים מחושבים לפי נתונים אמיתיים ומעודכנים, אך תמיד כדאי לבצע שיחה קצרה עם מומחה לפני התחייבות סופית.</p>
          </article>
          <article class="est-faq__item">
            <h3 class="est-faq__question">אפשר לשנות תשובות באמצע?</h3>
            <p class="est-faq__answer">בוודאי. אם תרצו לעדכן בחירות, התחילו חישוב חדש או הוסיפו עבודה נוספת כדי לראות תרחישים נוספים.</p>
          </article>
          <article class="est-faq__item">
            <h3 class="est-faq__question">מה קורה אחרי שקיבלתי תוצאה?</h3>
            <p class="est-faq__answer">לחצו על כפתור יצירת הקשר, ספרו לנו על הפרויקט ונחבר אתכם לבעל המקצוע המדויק ביותר.</p>
          </article>
        </div>
      </div>
    </section>
  </section>

  <script id="est-i18n" type="application/json">{{ t|tojson }}</script>
  <script id="est-cats" type="application/json">{{ categories|tojson }}</script>
{% endblock %}

{% block extra_scripts %}
  {{ super() }}

  <script>
    (function(){
      const i18n = JSON.parse(document.getElementById('est-i18n')?.textContent || '{}');
      const categories = JSON.parse(document.getElementById('est-cats')?.textContent || '[]');
      const lang = (document.documentElement.getAttribute('lang') || 'he').toLowerCase();
      const emojiFallback = {
        electricity: '\u26A1\uFE0E',
        plumbing: '\u{1F6B0}\uFE0E',
        painting: '\u{1F58C}\uFE0E',
        renovation: '\u{1F6E0}\uFE0E'
      };
      const emojiMap = categories.reduce((acc, cat) => {
        if (cat && cat.id){
          acc[cat.id] = cat.emoji || emojiFallback[cat.id] || '';
        }
        return acc;
      }, Object.assign({}, emojiFallback));
      const els = {
        body: document.querySelector('[data-est-body]'),
        progress: Array.from(document.querySelectorAll('[data-est-progress]')),
        progressPrimary: Array.from(document.querySelectorAll('[data-est-progress-primary]')),
        progressSecondary: Array.from(document.querySelectorAll('[data-est-progress-secondary]')),
        progressSteps: Array.from(document.querySelectorAll('[data-est-progress-step]')),
        journey: document.querySelector('[data-est-journey]')
      };
      const config = {
        contactUrl: document.querySelector('[data-est-contact]')?.getAttribute('data-est-contact') || ''
      };
      const focusableSelector = 'button:not(:disabled), [href], input:not(:disabled), select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"])';
      const state = {
        category: null,
        categoryLabel: '',
        job: null,
        jobLabel: '',
        subtype: null,
        subtypeLabel: '',
        answers: {},
        questions: [],
        resultNote: ''
      };
      const fallback = {
        'ui.ask_category': 'בחרו תחום עבודה',
        'ui.choose_job': 'איזו עבודה בדיוק צריך?',
        'ui.where_exactly': 'איזה סוג עבודה בדיוק?',
        'ui.loading_jobs': 'טוען עבודות מתאימות…',
        'ui.preparing_opts': 'מכין אפשרויות…',
        'ui.loading_questions': 'טוען שאלות מתאימות…',
        'ui.computing': 'מחשב תוצאה…',
        'ui.err_load_opts': 'בעיה זמנית בטעינת האפשרויות. נסו שוב.',
        'ui.err_load_subs': 'בעיה זמנית בטעינת האפשרויות.',
        'ui.err_load_qs': 'אירעה שגיאה בטעינת השאלות.',
        'ui.err_quote': 'שגיאה בהבאת הצעת המחיר.',
        'ui.field_label': 'תחום:',
        'ui.job_label': 'עבודה:',
        'ui.where_label': 'תת-סוג:',
        'ui.range_label': 'טווח מחיר משוער:',
        'ui.details_label': 'פירוט:',
        'ui.greeting': 'היי, נחשב יחד טווח מחיר משוער.',
        'ui.subtitle': 'ענו על כמה שאלות קצרות ונחשב טווח מחיר משוער לפי התחום שבחרתם.',
        'ui.result_note': 'הטווח מבוסס על נתונים של פרויקטים אמיתיים.',
        'ui.compute_btn': 'חשב טווח מחיר',
        'ui.add_more': 'נוסיף עבודה נוספת לחישוב המצטבר.',
        'ui.no_jobs': 'לא נמצאו עבודות זמינות לתחום שנבחר.',
        'ui.no_subtypes': 'אין תתי-סוג זמינים לעבודה הזו.',
        'ui.add_job_btn': 'הוספת עבודה נוספת',
        'ui.reset_btn': 'התחילו חישוב חדש',
        'ui.meta_ready_pick': 'מוכנים? בחרו תחום כדי שנתחיל.',
        'ui.meta_category_selected': 'התחום כבר נבחר. בואו נמשיך.',
        'ui.meta_restart': 'מתחילים מחדש את החישוב.',
        'ui.meta_add_job': 'בוחרים עבודה נוספת לאותו תחום.',
        'ui.result_cta_label': 'דברו עם מומחה להתאמת בעל מקצוע',
        'ui.result_cta_secondary': 'נשמור עבורכם את הטווח ונחזור עם הצעה מדויקת.',
        'ui.result_chart_heading': 'איך הטווח שלכם נראה במספרים',
        'ui.result_chart_note': 'התרשים מבוסס על הטווח שחישבנו עבורכם.',
        'ui.result_chart_columns_min': 'טווח נמוך',
        'ui.result_chart_columns_mid': 'אמצע הטווח',
        'ui.result_chart_columns_max': 'טווח גבוה',
        'ui.no_questions': 'אין שאלות נוספות. נחשב את הטווח מיד.',
        'ui.header_title': 'קבלו הערכת מחיר מדויקת תוך דקות',
        'ui.header_title_prefix': 'קבלו הערכת מחיר',
        'ui.header_title_highlight': 'מדויקת',
        'ui.header_title_suffix': 'תוך דקות',
        'ui.header_tagline': 'ענו על כמה שאלות קצרות וקבלו טווח מחיר שתפור בדיוק למה שאתם צריכים.',
        'ui.header_point_speed': 'ענו על כמה שאלות קצרות ותצאו לדרך.',
        'ui.header_point_accuracy': 'הטווחים מבוססים על אלפי עבודות אמיתיות.',
        'ui.header_point_confidence': 'אפשר לעדכן תשובות ולהוסיף עבודות בכל שלב.',
        'ui.assistant_intro': 'שלום! אני כאן כדי לתת לכם הערכת מחיר מדויקת.',
        'ui.assistant_subtitle': 'נתחיל בשאלות קצרות ומיד נבנה לכם טווח שמתאים בדיוק לעבודה שלכם.',
        'ui.progress_stage_category': 'בוחרים תחום',
        'ui.progress_stage_job': 'בוחרים את סוג העבודה',
        'ui.progress_stage_subtype': 'מדייקים את סוג העבודה',
        'ui.progress_stage_quote': 'עונים על כמה שאלות ממוקדות',
        'ui.progress_stage_result': 'הנה הטווח המשוער שלכם',
        'ui.progress_step_counter': 'שלב {current} מתוך {total}',
        'ui.progress_question_counter': 'שאלה {current} מתוך {total}',
        'ui.progress_done': 'החישוב הושלם',
        'ui.journey_empty': 'עוד לא בחרתם כלום — נתחיל בבחירת תחום.',
        'ui.journey_label': 'מה כבר בחרתם',
        'ui.category_hint_electricity': 'תיקוני חשמל, לוחות ותאורה',
        'ui.category_hint_plumbing': 'נזילות, פתיחת סתימות, התקנות',
        'ui.category_hint_painting': 'צביעת דירות, קירות מיוחדים',
        'ui.category_hint_renovation': 'שיפוצים, גבס, עבודות גמר',
        'ui.category_hint_locksmith': 'פריצות והחלפת צילינדרים'
      };
      const steps = ['category', 'job', 'subtype', 'quote'];
      const stageKeyMap = {
        category: 'ui.progress_stage_category',
        job: 'ui.progress_stage_job',
        subtype: 'ui.progress_stage_subtype',
        quote: 'ui.progress_stage_quote',
        result: 'ui.progress_stage_result'
      };
      const categoryHintKeyMap = {
        electricity: 'ui.category_hint_electricity',
        plumbing: 'ui.category_hint_plumbing',
        painting: 'ui.category_hint_painting',
        renovation: 'ui.category_hint_renovation',
        locksmith: 'ui.category_hint_locksmith'
      };
      let activeBotBubble = null;
      const currencyFormatter = (typeof Intl !== 'undefined' && Intl.NumberFormat)
        ? new Intl.NumberFormat(lang === 'he' ? 'he-IL' : 'en-US', {
            style: 'currency',
            currency: 'ILS',
            maximumFractionDigits: 0
          })
        : null;
      function t(key){
        return Object.prototype.hasOwnProperty.call(i18n, key) ? i18n[key] : (fallback[key] || '');
      }
      function setBusy(isBusy){
        if (!els.body) return;
        if (isBusy){
          els.body.setAttribute('aria-busy', 'true');
        } else {
          els.body.removeAttribute('aria-busy');
        }
      }
      function parseAmount(value){
        if (typeof value === 'number' && Number.isFinite(value)){
          return value;
        }
        if (typeof value === 'string'){
          const normalized = value
            .replace(/[\u2012\u2013\u2014\u2015\u2212]/g, '-')
            .replace(/[^0-9,.-]/g, '')
            .replace(/,(?=\d{3}\b)/g, '')
            .replace(/,/g, '.');
          const numeric = Number(normalized);
          return Number.isFinite(numeric) ? numeric : NaN;
        }
        return NaN;
      }
      function formatCurrencyValue(value){
        if (!Number.isFinite(value)){
          return '—';
        }
        if (currencyFormatter){
          try {
            return currencyFormatter.format(value);
          } catch (err) {
            // ignore and fall back below
          }
        }
        const rounded = Math.round(value);
        if (typeof rounded.toLocaleString === 'function'){
          return `₪${rounded.toLocaleString('he-IL')}`;
        }
        return `₪${rounded}`;
      }
      function clearFeed(){
        if (!els.body) return;
        els.body.innerHTML = '';
        activeBotBubble = null;
      }


      function focusFirstInteractive(scope){
        if (!scope) return;
        const target = scope.querySelector(focusableSelector);
        if (target && typeof target.focus === 'function'){
          try {
            target.focus({ preventScroll: true });
          } catch (err) {
            target.focus();
          }
        }
      }

      function ensureBubbleInView(bubble, shouldFocus){
        if (!bubble || !els.body) return;
        requestAnimationFrame(() => {
          if (typeof els.body.getBoundingClientRect === 'function'){
            const containerRect = els.body.getBoundingClientRect();
            const bubbleRect = bubble.getBoundingClientRect();
            const offset = bubbleRect.top - containerRect.top - (containerRect.height * 0.15);
            if (typeof els.body.scrollBy === 'function' && Math.abs(offset) > 1){
              els.body.scrollBy({ top: offset, behavior: 'smooth' });
            } else if (typeof bubble.scrollIntoView === 'function'){
              bubble.scrollIntoView({ block: 'start', behavior: 'smooth' });
            }
          } else if (typeof bubble.scrollIntoView === 'function'){
            bubble.scrollIntoView({ block: 'start', behavior: 'smooth' });
          }
          if (shouldFocus){
            focusFirstInteractive(bubble);
          }
        });
      }

      function createBubble(type){
        const article = document.createElement('article');
        article.className = `est-bubble est-bubble--${type}`;
        article.dataset.type = type;
        requestAnimationFrame(() => {
          article.classList.add('is-visible');
        });
        return article;
      }

      function appendBubble(bubble, options){
        if (!els.body || !bubble) return bubble;
        els.body.appendChild(bubble);

        const shouldFocus = options && Object.prototype.hasOwnProperty.call(options, 'focusInteractive')
          ? options.focusInteractive !== false
          : true;

        const shouldEnsure = options && Object.prototype.hasOwnProperty.call(options, 'ensureVisible')
          ? options.ensureVisible !== false
          : true;
        if (shouldEnsure){
          ensureBubbleInView(bubble, shouldFocus);
        } else if (shouldFocus){
          focusFirstInteractive(bubble);
        }
        return bubble;
      }
      function formatString(template, values){
        if (!template) return '';
        return template.replace(/\{(\w+)\}/g, (match, key) => {
          if (!values || !Object.prototype.hasOwnProperty.call(values, key)){
            return '';
          }
          const value = values[key];
          return value === undefined || value === null ? '' : String(value);
        });
      }
      function setProgressPrimary(text){
        if (!els.progressPrimary || !els.progressPrimary.length) return;
        els.progressPrimary.forEach((el) => {
          if (el){
            el.textContent = text || '';
          }
        });
      }
      function setProgressSecondary(text){
        if (!els.progressSecondary || !els.progressSecondary.length) return;
        els.progressSecondary.forEach((el) => {
          if (el){
            el.textContent = text || '';
          }
        });
      }

      function getStageLabel(stage){
        const key = stageKeyMap[stage];
        return key ? (t(key) || '') : '';
      }
      function getCategoryHint(id){
        const key = categoryHintKeyMap[id];
        return key ? (t(key) || '') : '';
      }
      function cleanLabel(text){
        return text ? text.replace(/[:：]\s*$/, '') : '';
      }
      function updateJourney(){
        if (!els.journey) return;
        els.journey.innerHTML = '';
        const selections = [];
        if (state.categoryLabel){
          selections.push({ label: cleanLabel(t('ui.field_label') || fallback['ui.field_label']), value: state.categoryLabel });
        }
        if (state.jobLabel){
          selections.push({ label: cleanLabel(t('ui.job_label') || fallback['ui.job_label']), value: state.jobLabel });
        }
        if (state.subtypeLabel && state.subtypeLabel !== state.jobLabel){
          selections.push({ label: cleanLabel(t('ui.where_label') || fallback['ui.where_label']), value: state.subtypeLabel });
        }
        if (!selections.length){
          const empty = document.createElement('span');
          empty.className = 'est-journey__empty';
          empty.textContent = t('ui.journey_empty') || fallback['ui.journey_empty'];
          els.journey.appendChild(empty);
          return;
        }
        const label = document.createElement('span');
        label.className = 'est-journey__label';
        label.textContent = t('ui.journey_label') || fallback['ui.journey_label'];
        els.journey.appendChild(label);
        const list = document.createElement('div');
        list.className = 'est-journey__list';
        selections.forEach((item) => {
          const pill = document.createElement('span');
          pill.className = 'est-journey__item';
          const labelEl = document.createElement('span');
          labelEl.className = 'est-journey__item-label';
          labelEl.textContent = item.label || '';
          pill.appendChild(labelEl);
          const valueEl = document.createElement('span');
          valueEl.className = 'est-journey__item-value';
          valueEl.textContent = item.value || '';
          pill.appendChild(valueEl);
          list.appendChild(pill);
        });
        els.journey.appendChild(list);
      }

      function appendBotBubble(content, options){

        const bubble = createBubble('bot');
        if (typeof content === 'string'){
          bubble.innerHTML = content;
        } else if (content){
          bubble.appendChild(content);
        }
        activeBotBubble = appendBubble(bubble, Object.assign({ focusInteractive: true }, options));


        return activeBotBubble;
      }
      function finalizeBotBubble(promptText, metaText){
        if (!activeBotBubble || activeBotBubble.dataset.type !== 'bot'){
          return;
        }
        const summary = document.createElement('div');
        summary.className = 'est-botcard est-botcard--locked';
        if (promptText){
          const heading = document.createElement('h3');
          heading.className = 'est-botcard__title';
          heading.textContent = promptText;
          summary.appendChild(heading);
        }
        if (metaText){
          const meta = document.createElement('p');
          meta.className = 'est-botcard__why';
          meta.textContent = metaText;
          summary.appendChild(meta);
        }
        activeBotBubble.innerHTML = '';
        activeBotBubble.appendChild(summary);
        activeBotBubble = null;
      }

      function appendUserBubble(label, symbol){

        const bubble = createBubble('user');
        const inner = document.createElement('div');
        inner.className = 'est-chip est-chip--selected';
        if (symbol){
          const emojiEl = document.createElement('span');
          emojiEl.className = 'est-chip__emoji';
          emojiEl.setAttribute('aria-hidden', 'true');
          emojiEl.textContent = symbol;
          inner.appendChild(emojiEl);
        }
        const span = document.createElement('span');
        span.textContent = label;
        inner.appendChild(span);
        bubble.appendChild(inner);
        appendBubble(bubble, { focusInteractive: false });

        return bubble;
      }

      function appendMetaBubble(text){
        if (!text) return null;
        const bubble = createBubble('meta');
        bubble.textContent = text;
        appendBubble(bubble, { focusInteractive: false });

        return bubble;
      }

      function appendErrorBubble(text){
        const bubble = createBubble('error');
        bubble.textContent = text;
        appendBubble(bubble, { focusInteractive: false });

        return bubble;
      }
      function buildResultChartData(result){
        if (!result) return null;
        const min = parseAmount(result.price_min);
        const max = parseAmount(result.price_max);
        const single = parseAmount(result.price);
        const hasRange = Number.isFinite(min) && Number.isFinite(max) && max >= min;
        const central = Number.isFinite(single)
          ? single
          : (hasRange ? (min + max) / 2 : NaN);
        const items = [];
        const minLabel = t('ui.result_chart_columns_min') || fallback['ui.result_chart_columns_min'] || '';
        const midLabel = t('ui.result_chart_columns_mid') || fallback['ui.result_chart_columns_mid'] || '';
        const maxLabel = t('ui.result_chart_columns_max') || fallback['ui.result_chart_columns_max'] || '';
        if (Number.isFinite(min)){
          items.push({ label: minLabel || 'Min', value: min, variant: 'low' });
        }
        if (Number.isFinite(central)){
          items.push({ label: midLabel || 'Mid', value: central, variant: 'highlight' });
        }
        if (hasRange && Number.isFinite(max)){
          items.push({ label: maxLabel || 'Max', value: max, variant: 'high' });
        } else if (!hasRange && Number.isFinite(max)){
          items.push({ label: maxLabel || 'Max', value: max, variant: 'high' });
        }
        if (!items.length){
          return null;
        }
        const maxValue = Math.max(...items.map(item => item.value));
        if (!(maxValue > 0)){
          return null;
        }
        return {
          items: items.map(item => Object.assign({}, item, {
            ratio: Math.max(0.12, Math.min(1, item.value / maxValue))
          }))
        };
      }
      function createResultChart(data){
        if (!data || !data.items || !data.items.length){
          return null;
        }
        const box = document.createElement('div');
        box.className = 'est-resultcard__chart';
        const titleText = t('ui.result_chart_heading') || fallback['ui.result_chart_heading'] || '';
        if (titleText){
          const title = document.createElement('h4');
          title.className = 'est-resultchart__title';
          title.textContent = titleText;
          box.appendChild(title);
        }
        const bars = document.createElement('div');
        bars.className = 'est-resultchart__bars';
        data.items.forEach((item) => {
          const bar = document.createElement('div');
          bar.className = 'est-resultchart__bar';
          if (item.variant){
            bar.classList.add(`is-${item.variant}`);
          }
          const value = document.createElement('div');
          value.className = 'est-resultchart__value';
          value.textContent = formatCurrencyValue(item.value);
          bar.appendChild(value);
          const meter = document.createElement('div');
          meter.className = 'est-resultchart__meter';
          const fill = document.createElement('div');
          fill.className = 'est-resultchart__fill';
          fill.style.setProperty('--bar-value', `${Math.round(item.ratio * 100)}%`);
          meter.appendChild(fill);
          bar.appendChild(meter);
          const label = document.createElement('div');
          label.className = 'est-resultchart__label';
          label.textContent = item.label || '';
          bar.appendChild(label);
          bars.appendChild(bar);
        });
        box.appendChild(bars);
        const noteText = t('ui.result_chart_note') || fallback['ui.result_chart_note'] || '';
        if (noteText){
          const note = document.createElement('p');
          note.className = 'est-resultchart__note';
          note.textContent = noteText;
          box.appendChild(note);
        }
        return box;
      }
      function makeLoadingNode(message){
        const wrap = document.createElement('div');
        wrap.className = 'est-loading';
        const icon = document.createElement('span');
        icon.className = 'est-loading__icon';
        icon.innerHTML = '<i class="fa-solid fa-circle-notch" aria-hidden="true"></i>';
        const text = document.createElement('span');
        text.className = 'est-loading__text';
        text.textContent = message;
        wrap.appendChild(text);
        wrap.insertBefore(icon, text);
        return wrap;
      }

      function replaceBotBubbleContent(node){
        if (!activeBotBubble){
          return appendBotBubble(node);
        }
        activeBotBubble.innerHTML = '';
        if (typeof node === 'string'){
          activeBotBubble.innerHTML = node;
        } else if (node){
          activeBotBubble.appendChild(node);
        }
        return activeBotBubble;
      }

      function fetchEstimate(payload){
        return fetch('/api/estimate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(Object.assign({ lang }, payload || {}))
        }).then(async (res) => {
          const data = await res.json();
          if (!res.ok){
            throw new Error(data && data.error ? data.error : 'Request failed');
          }
          return data;
        });
      }

      function resetState(){
        state.category = null;
        state.categoryLabel = '';
        state.job = null;
        state.jobLabel = '';
        state.subtype = null;
        state.subtypeLabel = '';
        state.answers = {};
        state.questions = [];
        state.resultNote = '';
      }

      function resetFlow(){
        resetState();
        updateProgress('category');
        updateJourney();
        clearFeed();
        setBusy(false);
        renderOnboarding();
      }
      function normalizeText(value){
        const stringValue = (value || '')
          .toString()
          .trim();
        if (!stringValue){
          return '';
        }
        const normalized = typeof stringValue.normalize === 'function'
          ? stringValue.normalize('NFKC')
          : stringValue;
        return normalized.toLowerCase();
      }
      function createChip(option, handler){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'est-chip';
        btn.dataset.value = option.id || option.value;
        const searchSource = [option.label, option.value, option.hint]

          .filter(Boolean)
          .map(str => normalizeText(str))
          .join(' ')
          .trim();
        btn.dataset.search = searchSource;
        if (option.hint){
          btn.dataset.hint = option.hint;
        }
        btn.setAttribute('role', 'listitem');
        btn.setAttribute('aria-pressed', 'false');
        btn.addEventListener('click', () => {
          handler(option);
        });
        btn.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' '){
            event.preventDefault();
            handler(option);
          }
        });
        if (option.emoji){
          const emojiEl = document.createElement('span');
          emojiEl.className = 'est-chip__emoji';
          emojiEl.setAttribute('aria-hidden', 'true');
          emojiEl.textContent = option.emoji;
          btn.appendChild(emojiEl);
        } else if (option.icon){
          const iconEl = document.createElement('i');
          iconEl.className = `fa-solid ${option.icon}`;
          iconEl.setAttribute('aria-hidden', 'true');
          btn.appendChild(iconEl);
        }
        const textWrap = document.createElement('span');
        textWrap.className = 'est-chip__text';
        const labelSpan = document.createElement('span');
        labelSpan.className = 'est-chip__label';
        labelSpan.textContent = option.label || option.value;
        textWrap.appendChild(labelSpan);
        if (option.hint){
          const hintSpan = document.createElement('span');
          hintSpan.className = 'est-chip__hint';
          hintSpan.textContent = option.hint;
          textWrap.appendChild(hintSpan);
        }
        btn.appendChild(textWrap);
        return btn;
      }
      function filterQuickPick(term, items, options){
        const normalized = normalizeText(term);
        const tokens = normalized ? normalized.split(/\s+/).filter(Boolean) : [];
        let matches = 0;
        items.forEach(item => {
          const haystack = item.dataset.search || '';
          const match = tokens.length === 0 || tokens.every(token => haystack.includes(token));
          item.hidden = !match;
          if (match){
            item.style.removeProperty('display');
            item.setAttribute('aria-hidden', 'false');
          } else {
            item.style.display = 'none';
            item.setAttribute('aria-hidden', 'true');
          }
          if (match){
            matches += 1;
          }
        });
        if (options && options.tip){
          const hideTip = tokens.length > 0;
          options.tip.hidden = hideTip;
          if (!hideTip){
            options.tip.removeAttribute('aria-hidden');
          } else {
            options.tip.setAttribute('aria-hidden', 'true');
          }
        }
        if (options && options.empty){
          const showEmpty = matches === 0;
          options.empty.hidden = !showEmpty;
          options.empty.setAttribute('aria-hidden', showEmpty ? 'false' : 'true');
        }
      }
      function renderCategoryQuickPick(){
        const wrap = document.createElement('div');
        wrap.className = 'est-quickpick';
        updateProgress('category', { label: t('ui.ask_category') || getStageLabel('category') });
        const heading = document.createElement('h2');
        heading.className = 'est-quickpick__title';
        heading.textContent = t('ui.ask_category');
        wrap.appendChild(heading);

        const searchWrap = document.createElement('div');
        searchWrap.className = 'est-search est-search--inline';
        const searchId = 'est-inline-search';
        const label = document.createElement('label');
        label.className = 'sr-only';
        label.setAttribute('for', searchId);
        label.textContent = t('ui.ask_category');
        const searchIcon = document.createElement('span');
        searchIcon.className = 'est-search__leading';
        searchIcon.innerHTML = '<i class="fa-solid fa-magnifying-glass" aria-hidden="true"></i>';
        const input = document.createElement('input');
        input.type = 'search';
        input.id = searchId;
        input.className = 'est-search__input';
        input.placeholder = '...חיפוש מהיר';
        input.autocomplete = 'off';
        const clear = document.createElement('button');
        clear.type = 'button';
        clear.className = 'est-search__clear';
        clear.setAttribute('aria-label', 'ניקוי החיפוש');
        clear.innerHTML = '<i class="fa-solid fa-xmark" aria-hidden="true"></i>';
        const list = document.createElement('div');
        list.className = 'est-quickpick__list';
        const emptyState = document.createElement('p');
        emptyState.className = 'est-quickpick__empty';
        emptyState.textContent = 'לא נמצאו תחומים תואמים לחיפוש.';
        emptyState.hidden = true;
        clear.addEventListener('click', () => {
          input.value = '';
          filterQuickPick(input.value, chips, filterState);


          input.focus();
        });
        input.addEventListener('input', () => {
          filterQuickPick(input.value, chips, filterState);


        });
        searchWrap.appendChild(searchIcon);
        searchWrap.appendChild(input);
        searchWrap.appendChild(clear);
        wrap.appendChild(label);
        wrap.appendChild(searchWrap);


        const chips = categories.map(cat => {
          const option = {
            id: cat.id,
            value: cat.id,
            label: cat.label,
            emoji: emojiMap[cat.id] || cat.emoji,
            hint: getCategoryHint(cat.id)
          };
          const chip = createChip(option, () => {
            handleCategoryPick(option);
          });
          chip.classList.add('est-chip--ghost', 'est-chip--full');
          list.appendChild(chip);
          return chip;
        });

        const tip = document.createElement('p');
        tip.className = 'est-quickpick__tip';
        tip.textContent = 'אנחנו שואלים כדי לדייק את הטווח המשוער.';

        const filterState = { empty: emptyState, tip };

        wrap.appendChild(list);
        wrap.appendChild(emptyState);
        wrap.appendChild(tip);
        appendBotBubble(wrap, { ensureVisible: false });

        filterQuickPick('', chips, filterState);

      }

      function setActiveCategory(id){
        document.querySelectorAll('.est-quickpick__list .est-chip').forEach(btn => {
          if (!(btn instanceof HTMLElement)) return;
          const selected = btn.dataset.value === id;
          btn.classList.toggle('est-chip--active', selected);
          btn.setAttribute('aria-pressed', selected ? 'true' : 'false');
        });
      }

      function updateProgress(step, options){
        const index = steps.indexOf(step);
        const totalSteps = steps.length;
        const progressIndex = index < 0 ? 0 : index;
        const denominator = Math.max(totalSteps - 1, 1);
        const percent = (progressIndex / denominator) * 100;
        if (els.progress && els.progress.length){
          const value = String(Math.round(percent));
          els.progress.forEach((progressEl) => {
            if (progressEl){
              progressEl.setAttribute('aria-valuenow', value);
              progressEl.style.setProperty('--progress', `${percent}%`);
            }
          });
        }
        const desiredLabel = options && Object.prototype.hasOwnProperty.call(options, 'label')
          ? options.label
          : getStageLabel(step);
        if (typeof desiredLabel === 'string'){
          setProgressPrimary(desiredLabel);
        }
        if (options && typeof options.secondary === 'string'){
          setProgressSecondary(options.secondary);
        } else {
          const counterTemplate = t('ui.progress_step_counter') || fallback['ui.progress_step_counter'] || '';
          const counterText = formatString(counterTemplate, {
            current: Math.max(1, progressIndex + 1),
            total: totalSteps
          });
          setProgressSecondary(counterText);
        }
        if (els.progressSteps && els.progressSteps.length){
          els.progressSteps.forEach((stepEl) => {
            if (!stepEl) return;
            const stepName = stepEl.getAttribute('data-est-progress-step');
            const stepIndex = steps.indexOf(stepName);
            const labelEl = stepEl.querySelector('[data-est-progress-label]');
            const defaultLabel = labelEl ? labelEl.getAttribute('data-default-label') : '';
            const isCurrent = stepIndex === progressIndex;
            const isComplete = stepIndex > -1 && stepIndex < progressIndex;
            stepEl.classList.toggle('is-active', isCurrent);
            stepEl.classList.toggle('is-complete', isComplete);
            if (isCurrent){
              stepEl.setAttribute('aria-current', 'step');
              if (labelEl && typeof desiredLabel === 'string'){
                labelEl.textContent = desiredLabel;
              }
            } else {
              stepEl.removeAttribute('aria-current');
              if (labelEl && typeof defaultLabel === 'string'){
                labelEl.textContent = defaultLabel;
              }
            }
          });
        }
      }

      function renderOnboarding(){
        const box = document.createElement('div');
        box.className = 'est-intro';
        const title = document.createElement('h1');
        title.textContent = t('ui.greeting');
        const subtitle = document.createElement('p');
        subtitle.textContent = t('ui.subtitle');
        box.appendChild(title);
        box.appendChild(subtitle);
        appendBotBubble(box);
        appendMetaBubble(t('ui.meta_ready_pick') || fallback['ui.meta_ready_pick']);
        renderCategoryQuickPick();
      }

      function handleCategoryPick(option){
        if (!option) return;
        if (state.category === option.id){
          appendMetaBubble(t('ui.meta_category_selected') || fallback['ui.meta_category_selected']);
          return;
        }
        finalizeBotBubble(t('ui.ask_category'));
        state.category = option.id;
        state.categoryLabel = option.label || option.id;
        state.job = null;
        state.jobLabel = '';
        state.subtype = null;
        state.subtypeLabel = '';
        state.answers = {};
        state.questions = [];
        state.resultNote = '';
        setActiveCategory(option.id);
        appendUserBubble(state.categoryLabel, emojiMap[option.id]);
        updateJourney();
        updateProgress('job', { label: t('ui.choose_job') || getStageLabel('job') });
        loadJobs();
      }

      function showLoading(key){
        const node = makeLoadingNode(t(key) || key);
        appendBotBubble(node);
        setBusy(true);
        const label = t(key) || key;
        if (label){
          setProgressPrimary(label);
        }
      }

      function showError(key){
        setBusy(false);

        const message = t(key) || key || 'בעיה זמנית.';
        if (activeBotBubble){
          activeBotBubble.className = 'est-bubble est-bubble--error';
          activeBotBubble.textContent = message;
          activeBotBubble = null;
          return;
        }
        appendErrorBubble(message);
      }

      function renderJobs(jobs){
        setBusy(false);
        updateProgress('job', { label: t('ui.choose_job') || getStageLabel('job') });
        const wrap = document.createElement('div');
        wrap.className = 'est-botcard';

        const title = document.createElement('h3');
        title.className = 'est-botcard__title';
        title.textContent = t('ui.choose_job');
        wrap.appendChild(title);
        if (!jobs.length){
          const empty = document.createElement('p');
          empty.className = 'est-botcard__empty';
          empty.textContent = t('ui.no_jobs');
          wrap.appendChild(empty);
          replaceBotBubbleContent(wrap);
          return;
        }
        const grid = document.createElement('div');
        grid.className = 'est-botcard__grid';
        grid.setAttribute('role', 'list');
        jobs.forEach(job => {
          const option = {
            id: job.id,
            value: job.id,
            label: job.label || job.id
          };
          const chip = createChip(option, () => {
            selectJob(job);
          });
          chip.classList.add('est-chip--ghost', 'est-chip--full');

          grid.appendChild(chip);
        });
        wrap.appendChild(grid);
        replaceBotBubbleContent(wrap);
      }

      function renderSubtypes(subtypes){
        setBusy(false);
        updateProgress('subtype', { label: t('ui.where_exactly') || getStageLabel('subtype') });

        const wrap = document.createElement('div');
        wrap.className = 'est-botcard';
        const title = document.createElement('h3');
        title.className = 'est-botcard__title';
        title.textContent = t('ui.where_exactly');
        wrap.appendChild(title);
        if (!subtypes.length){
          const empty = document.createElement('p');
          empty.className = 'est-botcard__empty';
          empty.textContent = t('ui.no_subtypes');
          wrap.appendChild(empty);
          replaceBotBubbleContent(wrap);
          return;
        }
        const grid = document.createElement('div');
        grid.className = 'est-botcard__grid';
        grid.setAttribute('role', 'list');
        subtypes.forEach(sub => {
          const option = {
            id: sub.id,
            value: sub.id,
            label: sub.label || sub.id
          };
          const chip = createChip(option, () => {
            selectSubtype(sub);
          });
          chip.classList.add('est-chip--ghost', 'est-chip--full');

          grid.appendChild(chip);
        });
        wrap.appendChild(grid);
        replaceBotBubbleContent(wrap);
      }

      function renderComputeCallToAction(){
        setBusy(false);

        const wrap = document.createElement('div');
        wrap.className = 'est-botcard est-botcard--cta';
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'est-btn est-btn--primary';
        button.textContent = t('ui.compute_btn');
        button.addEventListener('click', () => {
          button.disabled = true;
          appendMetaBubble(t('ui.computing'));
          computeQuote();
        });
        wrap.appendChild(button);
        appendBotBubble(wrap, { ensureVisible: false });
        updateProgress('quote', { label: getStageLabel('quote') });

      }

      function renderResult(result){
        setBusy(false);

        const wrap = document.createElement('div');
        wrap.className = 'est-resultcard';
        const heading = document.createElement('h3');
        heading.className = 'est-resultcard__title';
        heading.textContent = t('ui.range_label');
        wrap.appendChild(heading);
        const priceValue = parseAmount(result.price);
        const minValue = parseAmount(result.price_min);
        const maxValue = parseAmount(result.price_max);
        let priceText = '';
        if (Number.isFinite(priceValue)){
          priceText = formatCurrencyValue(priceValue);
        } else if (Number.isFinite(minValue) && Number.isFinite(maxValue)){
          priceText = `${formatCurrencyValue(minValue)} – ${formatCurrencyValue(maxValue)}`;
        }
        const range = document.createElement('p');
        range.className = 'est-resultcard__range';
        range.textContent = priceText || '—';
        wrap.appendChild(range);
        const noteText = result.result_note || state.resultNote || t('ui.result_note');
        if (noteText){
          const note = document.createElement('p');
          note.className = 'est-resultcard__note';
          note.textContent = noteText;
          wrap.appendChild(note);
        }
        if (result.description){
          const desc = document.createElement('p');
          desc.className = 'est-resultcard__desc';
          desc.textContent = `${t('ui.details_label')} ${result.description}`;
          wrap.appendChild(desc);
        }
        const extraCopy = t('ui.add_more');
        if (extraCopy){
          const extra = document.createElement('p');
          extra.className = 'est-resultcard__desc';
          extra.textContent = extraCopy;
          wrap.appendChild(extra);
        }
        const chartData = buildResultChartData(result);
        const chartNode = createResultChart(chartData);
        if (chartNode){
          wrap.appendChild(chartNode);
        }
        const ctaWrap = document.createElement('div');
        ctaWrap.className = 'est-resultcard__cta';
        const ctaNoteText = t('ui.result_cta_secondary') || fallback['ui.result_cta_secondary'] || '';
        if (ctaNoteText){
          const ctaNote = document.createElement('p');
          ctaNote.className = 'est-resultcard__cta-note';
          ctaNote.textContent = ctaNoteText;
          ctaWrap.appendChild(ctaNote);
        }
        const ctaLabel = t('ui.result_cta_label') || fallback['ui.result_cta_label'] || '';
        if (ctaLabel){
          const ctaBtn = document.createElement('a');
          ctaBtn.className = 'est-btn est-btn--primary est-btn--cta';
          ctaBtn.textContent = ctaLabel;
          if (config.contactUrl){
            ctaBtn.href = config.contactUrl;
          } else {
            ctaBtn.href = '#';
            ctaBtn.setAttribute('aria-disabled', 'true');
            ctaBtn.setAttribute('tabindex', '-1');
            ctaBtn.classList.add('is-disabled');
          }
          ctaWrap.appendChild(ctaBtn);
        }
        wrap.appendChild(ctaWrap);
        const actions = document.createElement('div');
        actions.className = 'est-resultcard__actions';
        const resetBtn = document.createElement('button');
        resetBtn.type = 'button';
        resetBtn.className = 'est-btn est-btn--ghost';
        resetBtn.textContent = t('ui.reset_btn') || fallback['ui.reset_btn'];
        resetBtn.addEventListener('click', () => {
          appendMetaBubble(t('ui.meta_restart') || fallback['ui.meta_restart']);
          resetFlow();
        });
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'est-btn est-btn--primary';
        addBtn.textContent = t('ui.add_job_btn') || fallback['ui.add_job_btn'];
        addBtn.addEventListener('click', () => {
          appendMetaBubble('בוחרים עבודה נוספת לאותו תחום.');
          state.job = null;
          state.jobLabel = '';
          state.subtype = null;
          state.subtypeLabel = '';
          state.answers = {};
          state.questions = [];
          updateJourney();
          updateProgress('job', { label: t('ui.choose_job') || getStageLabel('job') });
          loadJobs();
        });
        actions.appendChild(resetBtn);
        actions.appendChild(addBtn);
        wrap.appendChild(actions);
        replaceBotBubbleContent(wrap);
        updateJourney();
        const resultLabel = getStageLabel('result') || getStageLabel('quote');
        const doneText = t('ui.progress_done') || fallback['ui.progress_done'] || '';
        const progressOptions = { label: resultLabel };
        if (doneText){
          progressOptions.secondary = doneText;
        }
        updateProgress('quote', progressOptions);
      }

      function selectJob(job){
        if (!job) return;
        finalizeBotBubble(t('ui.choose_job'));
        state.job = job.id;
        state.jobLabel = job.label || job.id;
        state.subtype = null;
        state.subtypeLabel = '';
        state.answers = {};
        state.questions = [];
        state.resultNote = '';
        appendUserBubble(state.jobLabel);
        updateJourney();
        updateProgress('subtype', { label: t('ui.where_exactly') || getStageLabel('subtype') });
        loadSubtypes();
      }

      function selectSubtype(sub){
        if (!sub) return;
        finalizeBotBubble(t('ui.where_exactly'));
        state.subtype = sub.id;
        state.subtypeLabel = sub.label || sub.id;
        state.answers = {};
        state.questions = [];
        appendUserBubble(state.subtypeLabel);
        updateJourney();
        updateProgress('quote', { label: getStageLabel('quote') });
        loadQuestions();
      }

      function loadJobs(){
        if (!state.category) return;
        showLoading('ui.loading_jobs');
        fetchEstimate({ category: state.category }).then((data) => {
          renderJobs(data.jobs || []);
        }).catch((err) => {
          console.error(err);
          showError('ui.err_load_opts');
        });
      }

      function loadSubtypes(){
        if (!state.category || !state.job) return;
        showLoading('ui.preparing_opts');
        fetchEstimate({ category: state.category, job: state.job }).then((data) => {
          setBusy(false);

          const subtypes = data.subtypes || [];
          if (!subtypes.length){
            state.subtype = state.job;
            state.subtypeLabel = state.jobLabel;
            updateJourney();
            updateProgress('quote', { label: getStageLabel('quote') });
            loadQuestions();
            return;
          }
          renderSubtypes(subtypes);
        }).catch((err) => {
          console.error(err);
          showError('ui.err_load_subs');
        });
      }

      function loadQuestions(){
        if (!state.category || !state.job || !state.subtype) return;
        showLoading('ui.loading_questions');
        fetchEstimate({ category: state.category, job: state.job, subtype: state.subtype }).then((data) => {
          setBusy(false);

          state.questions = data.questions || [];
          state.resultNote = data.result_note || state.resultNote;
          renderQuestions(state.questions);
        }).catch((err) => {
          console.error(err);
          showError('ui.err_load_qs');
        });
      }
      function renderQuestions(questions){
        setBusy(false);
        updateProgress('quote', { label: getStageLabel('quote') });

        if (!questions.length){
          const wrap = document.createElement('div');
          wrap.className = 'est-botcard';
          const note = document.createElement('p');
          note.className = 'est-botcard__empty';
          note.textContent = t('ui.no_questions');
          wrap.appendChild(note);
          replaceBotBubbleContent(wrap);
          renderComputeCallToAction();
          return;
        }
        state.questions = questions;
        askQuestion(0);
      }

      function askQuestion(index){
        const q = state.questions[index];
        if (!q){
          renderComputeCallToAction();
          return;
        }
        showQuestion(q, index);
      }

      function showQuestion(question, index){
        const wrap = document.createElement('div');
        wrap.className = 'est-botcard';
        const title = document.createElement('h3');
        title.className = 'est-botcard__title';
        title.textContent = question.text || '';
        wrap.appendChild(title);
        let whyId = '';
        if (question.meta && question.meta.why){
          whyId = `why-${question.id}`;
          const why = document.createElement('p');
          why.className = 'est-botcard__why';
          why.id = whyId;
          why.textContent = question.meta.why;
          wrap.appendChild(why);
        }
        const grid = document.createElement('div');
        grid.className = 'est-botcard__grid';
        grid.setAttribute('role', 'list');
        (question.options || []).forEach(opt => {
          const option = {
            id: opt.value,
            value: opt.value,
            label: opt.label || opt.value
          };
          const chip = createChip(option, () => {
            if (grid.dataset.locked === 'true') return;
            grid.dataset.locked = 'true';
            Array.from(grid.children).forEach(child => {
              if (child instanceof HTMLButtonElement){
                child.disabled = true;
                child.classList.add('is-disabled');
                child.setAttribute('aria-pressed', child === chip ? 'true' : 'false');
              }
            });
            state.answers[question.id] = opt.value;
            finalizeBotBubble(question.text || '', question.meta && question.meta.why ? question.meta.why : '');
            appendUserBubble(option.label);
            askQuestion(index + 1);
          });
          if (whyId){
            chip.setAttribute('aria-describedby', whyId);
          }
          if (opt.hint){
            chip.dataset.hint = opt.hint;
          }
          grid.appendChild(chip);
        });
        wrap.appendChild(grid);
        replaceBotBubbleContent(wrap);
      }


      function computeQuote(){
        showLoading('ui.computing');
        fetchEstimate({ category: state.category, job: state.job, subtype: state.subtype, answers: state.answers }).then((data) => {
          setBusy(false);

          renderResult(data);
        }).catch((err) => {
          console.error(err);
          showError('ui.err_quote');
        });
      }
      resetFlow();
    })();
  </script>
{% endblock %}
