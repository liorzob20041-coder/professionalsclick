{% extends "base.html" %}

{% block title %}בעלי מקצוע בקליק — מחשבון{% endblock %}

{% block extra_head %}
  {{ super() }}
  <link rel="stylesheet" href="{{ static_rel('css/estimate.css') }}">
{% endblock %}

{% block content %}
  {% set t = i18n_est or {} %}
  {% set categories = [
    {"id": "electricity", "emoji": "\u26A1\uFE0E", "label": t.get('categories.electricity', 'חשמל')},
    {"id": "plumbing", "emoji": "\U0001F6B0\uFE0E", "label": t.get('categories.plumbing', 'אינסטלציה')},
    {"id": "painting", "emoji": "\U0001F58C\uFE0E", "label": t.get('categories.painting', 'צביעה')},
    {"id": "renovation", "emoji": "\U0001F6E0\uFE0E", "label": t.get('categories.renovation', 'שיפוצים')}
  ] %}
  <section class="est-page" aria-label="מחשבון הצעת מחיר">

    <header class="est-header">
      <div class="est-header__row">
        <div class="est-header__intro">
          <p class="est-header__brand" aria-label="בעלי מקצוע בקליק">בעלי מקצוע בקליק</p>
          <h1 class="est-header__title">{{ t.get('ui.header_title', 'מחשבון המחיר החכם שלנו') }}</h1>
        </div>
        <p class="est-header__lead">{{ t.get('ui.header_tagline', 'ענו על כמה שאלות קצרות וקבלו טווח מחיר שתפור בדיוק למה שאתם צריכים.') }}</p>
      </div>
      <div class="est-progresswrap">
        <div class="est-progress__meta">
          <span class="est-progress__primary" data-est-progress-primary>{{ t.get('ui.progress_stage_category', 'בוחרים תחום') }}</span>
          <span class="est-progress__secondary" data-est-progress-secondary>{{ t.get('ui.progress_step_counter', 'שלב 1 מתוך 4') }}</span>
        </div>
        <div class="est-progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" data-est-progress>
          <div class="est-progress__bar"></div>
        </div>
      </div>
      <div class="est-journey" data-est-journey>
        <span class="est-journey__empty">{{ t.get('ui.journey_empty', 'עוד לא בחרתם כלום — נתחיל בבחירת תחום.') }}</span>
      </div>

    </header>

    <section class="est-layout">
      <section class="est-convo" aria-label="שיחה עם מחשבון ההצעה">
        <div class="est-convo__body" data-est-body aria-live="polite"></div>
      </section>
    </section>
  </section>

  <script id="est-i18n" type="application/json">{{ t|tojson }}</script>
  <script id="est-cats" type="application/json">{{ categories|tojson }}</script>
{% endblock %}

{% block extra_scripts %}
  {{ super() }}

  <script>
    (function(){
      const i18n = JSON.parse(document.getElementById('est-i18n')?.textContent || '{}');
      const categories = JSON.parse(document.getElementById('est-cats')?.textContent || '[]');
      const lang = (document.documentElement.getAttribute('lang') || 'he').toLowerCase();
      const emojiFallback = {
        electricity: '\u26A1\uFE0E',
        plumbing: '\u{1F6B0}\uFE0E',
        painting: '\u{1F58C}\uFE0E',
        renovation: '\u{1F6E0}\uFE0E'
      };
      const emojiMap = categories.reduce((acc, cat) => {
        if (cat && cat.id){
          acc[cat.id] = cat.emoji || emojiFallback[cat.id] || '';
        }
        return acc;
      }, Object.assign({}, emojiFallback));
      const els = {
        body: document.querySelector('[data-est-body]'),
        progress: document.querySelector('[data-est-progress]'),
        progressPrimary: document.querySelector('[data-est-progress-primary]'),
        progressSecondary: document.querySelector('[data-est-progress-secondary]'),
        journey: document.querySelector('[data-est-journey]')
      };
      const focusableSelector = 'button:not(:disabled), [href], input:not(:disabled), select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"])';
      const state = {
        category: null,
        categoryLabel: '',
        job: null,
        jobLabel: '',
        subtype: null,
        subtypeLabel: '',
        answers: {},
        questions: [],
        resultNote: ''
      };
      const fallback = {
        'ui.ask_category': 'בחרו תחום עבודה',
        'ui.choose_job': 'איזו עבודה בדיוק צריך?',
        'ui.where_exactly': 'איזה סוג עבודה בדיוק?',
        'ui.loading_jobs': 'טוען עבודות מתאימות…',
        'ui.preparing_opts': 'מכין אפשרויות…',
        'ui.loading_questions': 'טוען שאלות מתאימות…',
        'ui.computing': 'מחשב תוצאה…',
        'ui.err_load_opts': 'בעיה זמנית בטעינת האפשרויות. נסו שוב.',
        'ui.err_load_subs': 'בעיה זמנית בטעינת האפשרויות.',
        'ui.err_load_qs': 'אירעה שגיאה בטעינת השאלות.',
        'ui.err_quote': 'שגיאה בהבאת הצעת המחיר.',
        'ui.field_label': 'תחום:',
        'ui.job_label': 'עבודה:',
        'ui.where_label': 'תת-סוג:',
        'ui.range_label': 'טווח מחיר משוער:',
        'ui.details_label': 'פירוט:',
        'ui.greeting': 'היי, נחשב יחד טווח מחיר משוער.',
        'ui.subtitle': 'ענו על כמה שאלות קצרות ונחשב טווח מחיר משוער לפי התחום שבחרתם.',
        'ui.result_note': 'הטווח מבוסס על נתונים של פרויקטים אמיתיים.',
        'ui.compute_btn': 'חשב טווח מחיר',
        'ui.add_more': 'נוסיף עבודה נוספת לחישוב המצטבר.',
        'ui.no_jobs': 'לא נמצאו עבודות זמינות לתחום שנבחר.',
        'ui.no_subtypes': 'אין תתי-סוג זמינים לעבודה הזו.',
        'ui.add_job_btn': 'הוספת עבודה נוספת',
        'ui.no_questions': 'אין שאלות נוספות. נחשב את הטווח מיד.',
        'ui.header_title': 'מחשבון המחיר החכם שלנו',
        'ui.header_tagline': 'ענו על כמה שאלות קצרות וקבלו טווח מחיר שתפור בדיוק למה שאתם צריכים.',
        'ui.progress_stage_category': 'בוחרים תחום',
        'ui.progress_stage_job': 'בוחרים את סוג העבודה',
        'ui.progress_stage_subtype': 'מדייקים את סוג העבודה',
        'ui.progress_stage_quote': 'עונים על כמה שאלות ממוקדות',
        'ui.progress_stage_result': 'הנה הטווח המשוער שלכם',
        'ui.progress_step_counter': 'שלב {current} מתוך {total}',
        'ui.progress_question_counter': 'שאלה {current} מתוך {total}',
        'ui.progress_done': 'החישוב הושלם',
        'ui.journey_empty': 'עוד לא בחרתם כלום — נתחיל בבחירת תחום.',
        'ui.journey_label': 'מה כבר בחרתם',
        'ui.category_hint_electricity': 'תיקוני חשמל, לוחות ותאורה',
        'ui.category_hint_plumbing': 'נזילות, פתיחת סתימות, התקנות',
        'ui.category_hint_painting': 'צביעת דירות, קירות מיוחדים',
        'ui.category_hint_renovation': 'שיפוצים, גבס, עבודות גמר',
        'ui.category_hint_locksmith': 'פריצות והחלפת צילינדרים'
      };
      const steps = ['category', 'job', 'subtype', 'quote'];
      const stageKeyMap = {
        category: 'ui.progress_stage_category',
        job: 'ui.progress_stage_job',
        subtype: 'ui.progress_stage_subtype',
        quote: 'ui.progress_stage_quote',
        result: 'ui.progress_stage_result'
      };
      const categoryHintKeyMap = {
        electricity: 'ui.category_hint_electricity',
        plumbing: 'ui.category_hint_plumbing',
        painting: 'ui.category_hint_painting',
        renovation: 'ui.category_hint_renovation',
        locksmith: 'ui.category_hint_locksmith'
      };
      let activeBotBubble = null;

      function t(key){
        return Object.prototype.hasOwnProperty.call(i18n, key) ? i18n[key] : (fallback[key] || '');
      }
      function setBusy(isBusy){
        if (!els.body) return;
        if (isBusy){
          els.body.setAttribute('aria-busy', 'true');
        } else {
          els.body.removeAttribute('aria-busy');
        }
      }
      function clearFeed(){
        if (!els.body) return;
        els.body.innerHTML = '';
        activeBotBubble = null;
      }


      function focusFirstInteractive(scope){
        if (!scope) return;
        const target = scope.querySelector(focusableSelector);
        if (target && typeof target.focus === 'function'){
          try {
            target.focus({ preventScroll: true });
          } catch (err) {
            target.focus();
          }
        }
      }

      function ensureBubbleInView(bubble, shouldFocus){
        if (!bubble || !els.body) return;
        requestAnimationFrame(() => {
          if (typeof els.body.getBoundingClientRect === 'function'){
            const containerRect = els.body.getBoundingClientRect();
            const bubbleRect = bubble.getBoundingClientRect();
            const offset = bubbleRect.top - containerRect.top - (containerRect.height * 0.15);
            if (typeof els.body.scrollBy === 'function' && Math.abs(offset) > 1){
              els.body.scrollBy({ top: offset, behavior: 'smooth' });
            } else if (typeof bubble.scrollIntoView === 'function'){
              bubble.scrollIntoView({ block: 'start', behavior: 'smooth' });
            }
          } else if (typeof bubble.scrollIntoView === 'function'){
            bubble.scrollIntoView({ block: 'start', behavior: 'smooth' });
          }
          if (shouldFocus){
            focusFirstInteractive(bubble);
          }
        });
      }

      function createBubble(type){
        const article = document.createElement('article');
        article.className = `est-bubble est-bubble--${type}`;
        article.dataset.type = type;
        requestAnimationFrame(() => {
          article.classList.add('is-visible');
        });
        return article;
      }

      function appendBubble(bubble, options){
        if (!els.body || !bubble) return bubble;
        els.body.appendChild(bubble);

        const shouldFocus = options && Object.prototype.hasOwnProperty.call(options, 'focusInteractive')
          ? options.focusInteractive !== false
          : true;

        const shouldEnsure = options && Object.prototype.hasOwnProperty.call(options, 'ensureVisible')
          ? options.ensureVisible !== false
          : true;
        if (shouldEnsure){
          ensureBubbleInView(bubble, shouldFocus);
        } else if (shouldFocus){
          focusFirstInteractive(bubble);
        }
        return bubble;
      }
      function formatString(template, values){
        if (!template) return '';
        return template.replace(/\{(\w+)\}/g, (match, key) => {
          if (!values || !Object.prototype.hasOwnProperty.call(values, key)){
            return '';
          }
          const value = values[key];
          return value === undefined || value === null ? '' : String(value);
        });
      }
      function setProgressPrimary(text){
        if (!els.progressPrimary) return;
        els.progressPrimary.textContent = text || '';
      }
      function setProgressSecondary(text){
        if (!els.progressSecondary) return;
        els.progressSecondary.textContent = text || '';
      }
      function getStageLabel(stage){
        const key = stageKeyMap[stage];
        return key ? (t(key) || '') : '';
      }
      function getCategoryHint(id){
        const key = categoryHintKeyMap[id];
        return key ? (t(key) || '') : '';
      }
      function cleanLabel(text){
        return text ? text.replace(/[:：]\s*$/, '') : '';
      }
      function updateJourney(){
        if (!els.journey) return;
        els.journey.innerHTML = '';
        const selections = [];
        if (state.categoryLabel){
          selections.push({ label: cleanLabel(t('ui.field_label') || fallback['ui.field_label']), value: state.categoryLabel });
        }
        if (state.jobLabel){
          selections.push({ label: cleanLabel(t('ui.job_label') || fallback['ui.job_label']), value: state.jobLabel });
        }
        if (state.subtypeLabel && state.subtypeLabel !== state.jobLabel){
          selections.push({ label: cleanLabel(t('ui.where_label') || fallback['ui.where_label']), value: state.subtypeLabel });
        }
        if (!selections.length){
          const empty = document.createElement('span');
          empty.className = 'est-journey__empty';
          empty.textContent = t('ui.journey_empty') || fallback['ui.journey_empty'];
          els.journey.appendChild(empty);
          return;
        }
        const label = document.createElement('span');
        label.className = 'est-journey__label';
        label.textContent = t('ui.journey_label') || fallback['ui.journey_label'];
        els.journey.appendChild(label);
        const list = document.createElement('div');
        list.className = 'est-journey__list';
        selections.forEach((item) => {
          const pill = document.createElement('span');
          pill.className = 'est-journey__item';
          const labelEl = document.createElement('span');
          labelEl.className = 'est-journey__item-label';
          labelEl.textContent = item.label || '';
          pill.appendChild(labelEl);
          const valueEl = document.createElement('span');
          valueEl.className = 'est-journey__item-value';
          valueEl.textContent = item.value || '';
          pill.appendChild(valueEl);
          list.appendChild(pill);
        });
        els.journey.appendChild(list);
      }

      function appendBotBubble(content, options){

        const bubble = createBubble('bot');
        if (typeof content === 'string'){
          bubble.innerHTML = content;
        } else if (content){
          bubble.appendChild(content);
        }
        activeBotBubble = appendBubble(bubble, Object.assign({ focusInteractive: true }, options));


        return activeBotBubble;
      }
      function finalizeBotBubble(promptText, metaText){
        if (!activeBotBubble || activeBotBubble.dataset.type !== 'bot'){
          return;
        }
        const summary = document.createElement('div');
        summary.className = 'est-botcard est-botcard--locked';
        if (promptText){
          const heading = document.createElement('h3');
          heading.className = 'est-botcard__title';
          heading.textContent = promptText;
          summary.appendChild(heading);
        }
        if (metaText){
          const meta = document.createElement('p');
          meta.className = 'est-botcard__why';
          meta.textContent = metaText;
          summary.appendChild(meta);
        }
        activeBotBubble.innerHTML = '';
        activeBotBubble.appendChild(summary);
        activeBotBubble = null;
      }

      function appendUserBubble(label, symbol){

        const bubble = createBubble('user');
        const inner = document.createElement('div');
        inner.className = 'est-chip est-chip--selected';
        if (symbol){
          const emojiEl = document.createElement('span');
          emojiEl.className = 'est-chip__emoji';
          emojiEl.setAttribute('aria-hidden', 'true');
          emojiEl.textContent = symbol;
          inner.appendChild(emojiEl);
        }
        const span = document.createElement('span');
        span.textContent = label;
        inner.appendChild(span);
        bubble.appendChild(inner);
        appendBubble(bubble, { focusInteractive: false });

        return bubble;
      }

      function appendMetaBubble(text){
        if (!text) return null;
        const bubble = createBubble('meta');
        bubble.textContent = text;
        appendBubble(bubble, { focusInteractive: false });

        return bubble;
      }

      function appendErrorBubble(text){
        const bubble = createBubble('error');
        bubble.textContent = text;
        appendBubble(bubble, { focusInteractive: false });

        return bubble;
      }

      function makeLoadingNode(message){
        const wrap = document.createElement('div');
        wrap.className = 'est-loading';
        const icon = document.createElement('span');
        icon.className = 'est-loading__icon';
        icon.innerHTML = '<i class="fa-solid fa-circle-notch" aria-hidden="true"></i>';
        const text = document.createElement('span');
        text.className = 'est-loading__text';
        text.textContent = message;
        wrap.appendChild(text);
        wrap.insertBefore(icon, text);
        return wrap;
      }

      function replaceBotBubbleContent(node){
        if (!activeBotBubble){
          return appendBotBubble(node);
        }
        activeBotBubble.innerHTML = '';
        if (typeof node === 'string'){
          activeBotBubble.innerHTML = node;
        } else if (node){
          activeBotBubble.appendChild(node);
        }
        return activeBotBubble;
      }

      function fetchEstimate(payload){
        return fetch('/api/estimate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(Object.assign({ lang }, payload || {}))
        }).then(async (res) => {
          const data = await res.json();
          if (!res.ok){
            throw new Error(data && data.error ? data.error : 'Request failed');
          }
          return data;
        });
      }

      function resetState(){
        state.category = null;
        state.categoryLabel = '';
        state.job = null;
        state.jobLabel = '';
        state.subtype = null;
        state.subtypeLabel = '';
        state.answers = {};
        state.questions = [];
        state.resultNote = '';
      }

      function resetFlow(){
        resetState();
        updateProgress('category');
        updateJourney();
        clearFeed();
        setBusy(false);
        renderOnboarding();
      }
      function normalizeText(value){
        const stringValue = (value || '')
          .toString()
          .trim();
        if (!stringValue){
          return '';
        }
        const normalized = typeof stringValue.normalize === 'function'
          ? stringValue.normalize('NFKC')
          : stringValue;
        return normalized.toLowerCase();
      }
      function createChip(option, handler){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'est-chip';
        btn.dataset.value = option.id || option.value;
        const searchSource = [option.label, option.value, option.hint]

          .filter(Boolean)
          .map(str => normalizeText(str))
          .join(' ')
          .trim();
        btn.dataset.search = searchSource;
        if (option.hint){
          btn.dataset.hint = option.hint;
        }
        btn.setAttribute('role', 'listitem');
        btn.setAttribute('aria-pressed', 'false');
        btn.addEventListener('click', () => {
          handler(option);
        });
        btn.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' '){
            event.preventDefault();
            handler(option);
          }
        });
        if (option.emoji){
          const emojiEl = document.createElement('span');
          emojiEl.className = 'est-chip__emoji';
          emojiEl.setAttribute('aria-hidden', 'true');
          emojiEl.textContent = option.emoji;
          btn.appendChild(emojiEl);
        } else if (option.icon){
          const iconEl = document.createElement('i');
          iconEl.className = `fa-solid ${option.icon}`;
          iconEl.setAttribute('aria-hidden', 'true');
          btn.appendChild(iconEl);
        }
        const textWrap = document.createElement('span');
        textWrap.className = 'est-chip__text';
        const labelSpan = document.createElement('span');
        labelSpan.className = 'est-chip__label';
        labelSpan.textContent = option.label || option.value;
        textWrap.appendChild(labelSpan);
        if (option.hint){
          const hintSpan = document.createElement('span');
          hintSpan.className = 'est-chip__hint';
          hintSpan.textContent = option.hint;
          textWrap.appendChild(hintSpan);
        }
        btn.appendChild(textWrap);
        return btn;
      }
      function filterQuickPick(term, items, options){
        const normalized = normalizeText(term);
        const tokens = normalized ? normalized.split(/\s+/).filter(Boolean) : [];
        let matches = 0;
        items.forEach(item => {
          const haystack = item.dataset.search || '';
          const match = tokens.length === 0 || tokens.every(token => haystack.includes(token));
          item.hidden = !match;
          if (match){
            item.style.removeProperty('display');
            item.setAttribute('aria-hidden', 'false');
          } else {
            item.style.display = 'none';
            item.setAttribute('aria-hidden', 'true');
          }
          if (match){
            matches += 1;
          }
        });
        if (options && options.tip){
          const hideTip = tokens.length > 0;
          options.tip.hidden = hideTip;
          if (!hideTip){
            options.tip.removeAttribute('aria-hidden');
          } else {
            options.tip.setAttribute('aria-hidden', 'true');
          }
        }
        if (options && options.empty){
          const showEmpty = matches === 0;
          options.empty.hidden = !showEmpty;
          options.empty.setAttribute('aria-hidden', showEmpty ? 'false' : 'true');
        }
      }
      function renderCategoryQuickPick(){
        const wrap = document.createElement('div');
        wrap.className = 'est-quickpick';
        updateProgress('category', { label: t('ui.ask_category') || getStageLabel('category') });
        const heading = document.createElement('h2');
        heading.className = 'est-quickpick__title';
        heading.textContent = t('ui.ask_category');
        wrap.appendChild(heading);

        const searchWrap = document.createElement('div');
        searchWrap.className = 'est-search est-search--inline';
        const searchId = 'est-inline-search';
        const label = document.createElement('label');
        label.className = 'sr-only';
        label.setAttribute('for', searchId);
        label.textContent = t('ui.ask_category');
        const searchIcon = document.createElement('span');
        searchIcon.className = 'est-search__leading';
        searchIcon.innerHTML = '<i class="fa-solid fa-magnifying-glass" aria-hidden="true"></i>';
        const input = document.createElement('input');
        input.type = 'search';
        input.id = searchId;
        input.className = 'est-search__input';
        input.placeholder = '...חיפוש מהיר';
        input.autocomplete = 'off';
        const clear = document.createElement('button');
        clear.type = 'button';
        clear.className = 'est-search__clear';
        clear.setAttribute('aria-label', 'ניקוי החיפוש');
        clear.innerHTML = '<i class="fa-solid fa-xmark" aria-hidden="true"></i>';
        const list = document.createElement('div');
        list.className = 'est-quickpick__list';
        const emptyState = document.createElement('p');
        emptyState.className = 'est-quickpick__empty';
        emptyState.textContent = 'לא נמצאו תחומים תואמים לחיפוש.';
        emptyState.hidden = true;
        clear.addEventListener('click', () => {
          input.value = '';
          filterQuickPick(input.value, chips, filterState);


          input.focus();
        });
        input.addEventListener('input', () => {
          filterQuickPick(input.value, chips, filterState);


        });
        searchWrap.appendChild(searchIcon);
        searchWrap.appendChild(input);
        searchWrap.appendChild(clear);
        wrap.appendChild(label);
        wrap.appendChild(searchWrap);


        const chips = categories.map(cat => {
          const option = {
            id: cat.id,
            value: cat.id,
            label: cat.label,
            emoji: emojiMap[cat.id] || cat.emoji,
            hint: getCategoryHint(cat.id)
          };
          const chip = createChip(option, () => {
            handleCategoryPick(option);
          });
          chip.classList.add('est-chip--ghost', 'est-chip--full');
          list.appendChild(chip);
          return chip;
        });

        const tip = document.createElement('p');
        tip.className = 'est-quickpick__tip';
        tip.textContent = 'אנחנו שואלים כדי לדייק את הטווח המשוער.';

        const filterState = { empty: emptyState, tip };

        wrap.appendChild(list);
        wrap.appendChild(emptyState);
        wrap.appendChild(tip);
        appendBotBubble(wrap, { ensureVisible: false });

        filterQuickPick('', chips, filterState);

      }

      function setActiveCategory(id){
        document.querySelectorAll('.est-quickpick__list .est-chip').forEach(btn => {
          if (!(btn instanceof HTMLElement)) return;
          const selected = btn.dataset.value === id;
          btn.classList.toggle('est-chip--active', selected);
          btn.setAttribute('aria-pressed', selected ? 'true' : 'false');
        });
      }

      function updateProgress(step, options){
        const index = steps.indexOf(step);
        const totalSteps = steps.length;
        const progressIndex = index < 0 ? 0 : index;
        const denominator = Math.max(totalSteps - 1, 1);
        const percent = (progressIndex / denominator) * 100;
        if (els.progress){
          els.progress.setAttribute('aria-valuenow', String(Math.round(percent)));
          els.progress.style.setProperty('--progress', `${percent}%`);
        }
        const desiredLabel = options && Object.prototype.hasOwnProperty.call(options, 'label')
          ? options.label
          : getStageLabel(step);
        if (typeof desiredLabel === 'string'){
          setProgressPrimary(desiredLabel);
        }
        if (options && typeof options.secondary === 'string'){
          setProgressSecondary(options.secondary);
        } else {
          const counterTemplate = t('ui.progress_step_counter') || fallback['ui.progress_step_counter'] || '';
          const counterText = formatString(counterTemplate, {
            current: Math.max(1, progressIndex + 1),
            total: totalSteps
          });
          setProgressSecondary(counterText);
        }
      }

      function renderOnboarding(){
        const box = document.createElement('div');
        box.className = 'est-intro';
        const title = document.createElement('h1');
        title.textContent = t('ui.greeting');
        const subtitle = document.createElement('p');
        subtitle.textContent = t('ui.subtitle');
        box.appendChild(title);
        box.appendChild(subtitle);
        appendBotBubble(box);
        appendMetaBubble('מוכנים? בחרו תחום כדי שנתחיל.');
        renderCategoryQuickPick();
      }

      function handleCategoryPick(option){
        if (!option) return;
        if (state.category === option.id){
          appendMetaBubble('התחום כבר נבחר. בואו נמשיך.');
          return;
        }
        finalizeBotBubble(t('ui.ask_category'));
        state.category = option.id;
        state.categoryLabel = option.label || option.id;
        state.job = null;
        state.jobLabel = '';
        state.subtype = null;
        state.subtypeLabel = '';
        state.answers = {};
        state.questions = [];
        state.resultNote = '';
        setActiveCategory(option.id);
        appendUserBubble(state.categoryLabel, emojiMap[option.id]);
        updateJourney();
        updateProgress('job', { label: t('ui.choose_job') || getStageLabel('job') });
        loadJobs();
      }

      function showLoading(key){
        const node = makeLoadingNode(t(key) || key);
        appendBotBubble(node);
        setBusy(true);
        const label = t(key) || key;
        if (label){
          setProgressPrimary(label);
        }
      }

      function showError(key){
        setBusy(false);

        const message = t(key) || key || 'בעיה זמנית.';
        if (activeBotBubble){
          activeBotBubble.className = 'est-bubble est-bubble--error';
          activeBotBubble.textContent = message;
          activeBotBubble = null;
          return;
        }
        appendErrorBubble(message);
      }

      function renderJobs(jobs){
        setBusy(false);
        updateProgress('job', { label: t('ui.choose_job') || getStageLabel('job') });
        const wrap = document.createElement('div');
        wrap.className = 'est-botcard';
        const totalQuestions = state.questions.length;
        const progressOptions = { label: question.text || getStageLabel('quote') };
        if (totalQuestions > 0){
          const template = t('ui.progress_question_counter') || fallback['ui.progress_question_counter'] || '';
          const questionNumber = Math.min(index + 1, totalQuestions);
          const secondaryText = formatString(template, { current: questionNumber, total: totalQuestions });
          if (secondaryText){
            progressOptions.secondary = secondaryText;
          }
        }
        updateProgress('quote', progressOptions);
        const title = document.createElement('h3');
        title.className = 'est-botcard__title';
        title.textContent = t('ui.choose_job');
        wrap.appendChild(title);
        if (!jobs.length){
          const empty = document.createElement('p');
          empty.className = 'est-botcard__empty';
          empty.textContent = t('ui.no_jobs');
          wrap.appendChild(empty);
          replaceBotBubbleContent(wrap);
          return;
        }
        const grid = document.createElement('div');
        grid.className = 'est-botcard__grid';
        grid.setAttribute('role', 'list');
        jobs.forEach(job => {
          const option = {
            id: job.id,
            value: job.id,
            label: job.label || job.id
          };
          const chip = createChip(option, () => {
            selectJob(job);
          });
          chip.classList.add('est-chip--ghost', 'est-chip--full');

          grid.appendChild(chip);
        });
        wrap.appendChild(grid);
        replaceBotBubbleContent(wrap);
      }

      function renderSubtypes(subtypes){
        setBusy(false);
        updateProgress('subtype', { label: t('ui.where_exactly') || getStageLabel('subtype') });

        const wrap = document.createElement('div');
        wrap.className = 'est-botcard';
        const title = document.createElement('h3');
        title.className = 'est-botcard__title';
        title.textContent = t('ui.where_exactly');
        wrap.appendChild(title);
        if (!subtypes.length){
          const empty = document.createElement('p');
          empty.className = 'est-botcard__empty';
          empty.textContent = t('ui.no_subtypes');
          wrap.appendChild(empty);
          replaceBotBubbleContent(wrap);
          return;
        }
        const grid = document.createElement('div');
        grid.className = 'est-botcard__grid';
        grid.setAttribute('role', 'list');
        subtypes.forEach(sub => {
          const option = {
            id: sub.id,
            value: sub.id,
            label: sub.label || sub.id
          };
          const chip = createChip(option, () => {
            selectSubtype(sub);
          });
          chip.classList.add('est-chip--ghost', 'est-chip--full');

          grid.appendChild(chip);
        });
        wrap.appendChild(grid);
        replaceBotBubbleContent(wrap);
      }

      function renderComputeCallToAction(){
        setBusy(false);

        const wrap = document.createElement('div');
        wrap.className = 'est-botcard est-botcard--cta';
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'est-btn est-btn--primary';
        button.textContent = t('ui.compute_btn');
        button.addEventListener('click', () => {
          button.disabled = true;
          appendMetaBubble(t('ui.computing'));
          computeQuote();
        });
        wrap.appendChild(button);
        appendBotBubble(wrap, { ensureVisible: false });
        updateProgress('quote', { label: getStageLabel('quote') });

      }

      function renderResult(result){
        setBusy(false);

        const wrap = document.createElement('div');
        wrap.className = 'est-resultcard';
        const heading = document.createElement('h3');
        heading.className = 'est-resultcard__title';
        heading.textContent = t('ui.range_label');
        wrap.appendChild(heading);
        const priceText = result.price || (result.price_min && result.price_max ? `₪${result.price_min}–₪${result.price_max}` : '');
        const range = document.createElement('p');
        range.className = 'est-resultcard__range';
        range.textContent = priceText || '—';
        wrap.appendChild(range);
        const noteText = result.result_note || state.resultNote || t('ui.result_note');
        if (noteText){
          const note = document.createElement('p');
          note.className = 'est-resultcard__note';
          note.textContent = noteText;
          wrap.appendChild(note);
        }
        if (result.description){
          const desc = document.createElement('p');
          desc.className = 'est-resultcard__desc';
          desc.textContent = `${t('ui.details_label')} ${result.description}`;
          wrap.appendChild(desc);
        }
        const extraCopy = t('ui.add_more');
        if (extraCopy){
          const extra = document.createElement('p');
          extra.className = 'est-resultcard__desc';
          extra.textContent = extraCopy;
          wrap.appendChild(extra);
        }

        const actions = document.createElement('div');
        actions.className = 'est-resultcard__actions';
        const resetBtn = document.createElement('button');
        resetBtn.type = 'button';
        resetBtn.className = 'est-btn est-btn--ghost';
        resetBtn.textContent = 'התחל מחדש';
        resetBtn.addEventListener('click', () => {
          appendMetaBubble('מתחילים מחדש את החישוב.');
          resetFlow();
        });
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'est-btn est-btn--primary';
        addBtn.textContent = 'הוסף עבודה נוספת';
        addBtn.addEventListener('click', () => {
          appendMetaBubble('בוחרים עבודה נוספת לאותו תחום.');
          state.job = null;
          state.jobLabel = '';
          state.subtype = null;
          state.subtypeLabel = '';
          state.answers = {};
          state.questions = [];
          updateJourney();
          updateProgress('job', { label: t('ui.choose_job') || getStageLabel('job') });
          loadJobs();
        });
        actions.appendChild(resetBtn);
        actions.appendChild(addBtn);
        wrap.appendChild(actions);
        replaceBotBubbleContent(wrap);
        updateJourney();
        const resultLabel = getStageLabel('result') || getStageLabel('quote');
        const doneText = t('ui.progress_done') || fallback['ui.progress_done'] || '';
        const progressOptions = { label: resultLabel };
        if (doneText){
          progressOptions.secondary = doneText;
        }
        updateProgress('quote', progressOptions);
      }

      function selectJob(job){
        if (!job) return;
        finalizeBotBubble(t('ui.choose_job'));
        state.job = job.id;
        state.jobLabel = job.label || job.id;
        state.subtype = null;
        state.subtypeLabel = '';
        state.answers = {};
        state.questions = [];
        state.resultNote = '';
        appendUserBubble(state.jobLabel);
        updateJourney();
        updateProgress('subtype', { label: t('ui.where_exactly') || getStageLabel('subtype') });
        loadSubtypes();
      }

      function selectSubtype(sub){
        if (!sub) return;
        finalizeBotBubble(t('ui.where_exactly'));
        state.subtype = sub.id;
        state.subtypeLabel = sub.label || sub.id;
        state.answers = {};
        state.questions = [];
        appendUserBubble(state.subtypeLabel);
        updateJourney();
        updateProgress('quote', { label: getStageLabel('quote') });
        loadQuestions();
      }

      function loadJobs(){
        if (!state.category) return;
        showLoading('ui.loading_jobs');
        fetchEstimate({ category: state.category }).then((data) => {
          renderJobs(data.jobs || []);
        }).catch((err) => {
          console.error(err);
          showError('ui.err_load_opts');
        });
      }

      function loadSubtypes(){
        if (!state.category || !state.job) return;
        showLoading('ui.preparing_opts');
        fetchEstimate({ category: state.category, job: state.job }).then((data) => {
          setBusy(false);

          const subtypes = data.subtypes || [];
          if (!subtypes.length){
            state.subtype = state.job;
            state.subtypeLabel = state.jobLabel;
            updateJourney();
            updateProgress('quote', { label: getStageLabel('quote') });
            loadQuestions();
            return;
          }
          renderSubtypes(subtypes);
        }).catch((err) => {
          console.error(err);
          showError('ui.err_load_subs');
        });
      }

      function loadQuestions(){
        if (!state.category || !state.job || !state.subtype) return;
        showLoading('ui.loading_questions');
        fetchEstimate({ category: state.category, job: state.job, subtype: state.subtype }).then((data) => {
          setBusy(false);

          state.questions = data.questions || [];
          state.resultNote = data.result_note || state.resultNote;
          renderQuestions(state.questions);
        }).catch((err) => {
          console.error(err);
          showError('ui.err_load_qs');
        });
      }
      function renderQuestions(questions){
        setBusy(false);
        updateProgress('quote', { label: getStageLabel('quote') });

        if (!questions.length){
          const wrap = document.createElement('div');
          wrap.className = 'est-botcard';
          const note = document.createElement('p');
          note.className = 'est-botcard__empty';
          note.textContent = t('ui.no_questions');
          wrap.appendChild(note);
          replaceBotBubbleContent(wrap);
          renderComputeCallToAction();
          return;
        }
        state.questions = questions;
        askQuestion(0);
      }

      function askQuestion(index){
        const q = state.questions[index];
        if (!q){
          renderComputeCallToAction();
          return;
        }
        showQuestion(q, index);
      }

      function showQuestion(question, index){
        const wrap = document.createElement('div');
        wrap.className = 'est-botcard';
        const title = document.createElement('h3');
        title.className = 'est-botcard__title';
        title.textContent = question.text || '';
        wrap.appendChild(title);
        let whyId = '';
        if (question.meta && question.meta.why){
          whyId = `why-${question.id}`;
          const why = document.createElement('p');
          why.className = 'est-botcard__why';
          why.id = whyId;
          why.textContent = question.meta.why;
          wrap.appendChild(why);
        }
        const grid = document.createElement('div');
        grid.className = 'est-botcard__grid';
        grid.setAttribute('role', 'list');
        (question.options || []).forEach(opt => {
          const option = {
            id: opt.value,
            value: opt.value,
            label: opt.label || opt.value
          };
          const chip = createChip(option, () => {
            if (grid.dataset.locked === 'true') return;
            grid.dataset.locked = 'true';
            Array.from(grid.children).forEach(child => {
              if (child instanceof HTMLButtonElement){
                child.disabled = true;
                child.classList.add('is-disabled');
                child.setAttribute('aria-pressed', child === chip ? 'true' : 'false');
              }
            });
            state.answers[question.id] = opt.value;
            finalizeBotBubble(question.text || '', question.meta && question.meta.why ? question.meta.why : '');
            appendUserBubble(option.label);
            askQuestion(index + 1);
          });
          if (whyId){
            chip.setAttribute('aria-describedby', whyId);
          }
          if (opt.hint){
            chip.dataset.hint = opt.hint;
          }
          grid.appendChild(chip);
        });
        wrap.appendChild(grid);
        replaceBotBubbleContent(wrap);
      }


      function computeQuote(){
        showLoading('ui.computing');
        fetchEstimate({ category: state.category, job: state.job, subtype: state.subtype, answers: state.answers }).then((data) => {
          setBusy(false);

          renderResult(data);
        }).catch((err) => {
          console.error(err);
          showError('ui.err_quote');
        });
      }

      resetFlow();
    })();
  </script>
{% endblock %}
